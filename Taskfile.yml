version: "3"

tasks:
  # Dynamically run services using default containerization with docker-compose
  # task do <service_name>:<environment>:<action>
  do:*:*:*:
    vars:
      service: "{{index .MATCH 0}}"
      mode: "{{index .MATCH 1}}"
      action: "{{index .MATCH 2}}"
      # Set env_file based on whether mode is not 'prod'
      env_file: '{{ if ne .mode "prod" }}.env.{{.mode}}{{ else }}.env{{ end }}'
      docker_compose_up: '{{ if ne .mode "prod" }}docker-compose {{.action}} {{.CLI_ARGS}}{{ else }}docker-compose  -f docker-compose.yml -f production.yml {{.action}} {{.CLI_ARGS}} {{ end }}'

    cmds:
      - |
        if ! docker info > /dev/null 2>&1; then
          echo "Docker is not running. Attempting to start Docker..."
          echo -------------------------------------------------------
          case "$(uname -s)" in
            Darwin)
              echo platform : MacOS : starting docker daemon...
              echo -------------------------------------------------------
              open /Applications/Docker.app
              ;;
            Linux)
              echo platform : Linux : starting docker daemon...
              echo -------------------------------------------------------
              systemctl start docker
              ;;
            *)
              echo "Unsupported operating system. Please start Docker manually. and try task run:{{.mode}}:{{.service}} again..."
              echo -------------------------------------------------------
              exit 1
              ;;
          esac
          sleep 10
        fi
        if ! docker info > /dev/null 2>&1; then
          echo "Failed to start Docker. Please check your Docker installation."
          exit 1
        else
          echo "Docker is running."
          echo -------------------------------------------------------
        fi

      # Search for the service directory from anywhere using BFS algorithm and upgrade package.json
      - |
        bfs_search() {
          start_dir="$1"
          target_file="$2"
          queue=("$start_dir")
          while [ ${#queue[@]} -gt 0 ]; do
            current_dir="${queue[0]}"
            queue=("${queue[@]:1}")
            for entry in "$current_dir"/*; do
              if [ -d "$entry" ]; then
                queue+=("$entry")
              elif [ "${entry##*/}" = "$target_file" ]; then
                echo "Found directory with $target_file: $current_dir"
                cd "$current_dir"
                yarn install
                yarn upgrade
                exit 0
              fi
            done
          done
          echo "Service directory for '$service' not found."
          exit 1
        }
        bfs_search "$(pwd)" "package.json"

      # Print a newline to separate loading state from subsequent output
      - echo -------------------------------------------------------

      # Commands to start your containers go here
      - echo "Loading complete. Starting Docker containers..."
      - echo -------------------------------------------------------
      - echo "cleaning up the the repo to prepare for building the image..."
      - echo -------------------------------------------------------
      - yarn repo:reset
      - echo -------------------------------------------------------
      - echo "cleanup done. Starting to build docker image....."
      - echo -------------------------------------------------------
      - docker-compose down
      - echo -------------------------------------------------------
      - "{{.docker_compose_up}}"
      - echo -------------------------------------------------------
    # silent: true

  # Dynamically run services using node server engines PM2 in prod and nodemon in dev mode
  vanilla:*:*:
    vars:
      mode: "{{index .MATCH 0}}"
      service: "{{index .MATCH 1}}"
      # Set env_file based on whether mode is not 'prod'
      env_file: '{{ if ne .mode "prod" }}.env.{{.mode}}{{ else }}.env{{ end }}'
    cmds:
      - >
        [ -f ./microservices/{{.service}}/{{.env_file}} ] || 
        (echo "You need to add the {{.env_file}} file with environment variable configurations to proceed" && exit 1)
      - yarn repo:reset
      - yarn install
      - >
        yarn workspace @microservices-suite/{{.service}} '{{ if ne .mode "prod" }}{{.mode}}{{ else }}start{{ end }}'

  # TODO: Orchestrate services with kubernetes inside minikube clusters and kubectl
  k8s:*:*:
    vars:
      mode: "{{index .MATCH 0}}"
      service: "{{index .MATCH 1}}"
      #TODO: build dynamic file matching paths to k8 configurations here

      #TODO: build dynamic k8 commands here
    cmds:
      - "#TODO: enerate dynamic orchestration workflows based on [mode] & [service]"

  # TODO: Run your tests using jest or any test suite of choice
  test:*:*:
    vars:
      type: "{{index .MATCH 0}}" #type to match [unit,e2e,snapshot,all]
      service: "{{index .MATCH 1}}" #service to match [<service_name>,<glob-patterns>,all]
      #TODO: build dynamic file matching paths to test pyramid here

      #TODO: build dynamic test commands here
    cmds:
      - "#TODO: generate dynamic testing workflows based on [type] & [service]"

  # TODO: create a utilities glossary to switch {{.CLI_ARGS}} eg utilities: case --reset do; case --stop do; case etc ...
  reset:
    cmds:
      - "yarn repo:reset" #deep remove all node modules and artefacts generated during yarn install

