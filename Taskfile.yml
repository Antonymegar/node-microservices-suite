version: "3"

tasks:
  # Dynamically run services using default containerization with docker-compose
  # task do <service_name>:<environment>:<action>
  do:*:*:*:
    vars:
      service: "{{index .MATCH 0}}"
      mode: "{{index .MATCH 1}}"
      action: "{{index .MATCH 2}}"
      # Set env_file based on whether mode is not 'prod'
      env_file: '{{ if ne .mode "prod" }}.env.{{.mode}}{{ else }}.env{{ end }}'
      docker_compose: '{{ if ne .mode "prod" }}docker-compose {{.action}} {{.CLI_ARGS}}{{ else }}docker-compose  -f docker-compose.yml -f production.yml {{.action}} {{.CLI_ARGS}} {{ end }}'

    cmds:
      - >
        [ -f ./microservices/{{.service}}/{{.env_file}} ] || 
        (echo "You need to add the {{.env_file}} file with environment variable configurations to proceed" && exit 1)
      - >
        if [ "{{.action}}" == "down" ]; then
          {{.docker_compose}}
          exit 0
        fi
      - |
        if ! docker info > /dev/null 2>&1; then
          echo "Docker is not running. Attempting to start Docker..."
          case "$(uname -s)" in
            Darwin)
              echo '---------------------------------------'
              echo platform : MacOS : starting docker daemon...
              echo '---------------------------------------'
              open /Applications/Docker.app
              ;;
            Linux)
              echo '---------------------------------------'
              echo platform : Linux : starting docker daemon...
              echo '---------------------------------------'
              systemctl start docker
              ;;
            *)
              echo "Unsupported operating system. Please start Docker manually. and try task run:{{.mode}}:{{.service}} again..."
              echo '!! -----------------------------------------------------'
              exit 1
              ;;
          esac
          sleep 10
        fi
        if ! docker info > /dev/null 2>&1; then
          echo "ðŸ’” Failed to start Docker. Please check your Docker installation."
          exit 1
        else
          if [ "{{.action}}" != "down" ]; then echo "âœ… ==>Docker is running..."; else exit 0; fi
        fi

      # Search for the service directory from anywhere and upgrade package.json
      - >
        if [ "{{.action}}" == "up" ]; then
            function search_service_root_from_cwd() {
                cwd="$1"
                service="$2"
                split_cwd=(${cwd//\// })
                if [[ " ${split_cwd[@]} " =~ " node-microservices-suite " ]]; then
                    service_root=$(echo "${split_cwd[*]:0:${#split_cwd[@]}-2}" | tr ' ' '/')/microservices/$service
                    cd "/$service_root" || { echo "Error: Unable to change directory to $service_root"; exit 1; }
                    echo '-----------------------------------------------------'
                    if [ -f yarn.lock ]; then
                        rm yarn.lock
                    fi
                    echo "Found directory with $target_file: $service_root"
                    echo '-----------------------------------------------------'
                    echo cd...ing into $service_root
                    echo '-----------------------------------------------------'
                    echo '==> installing packages'
                    yarn install
                    echo '==> upgrading packages'
                    yarn upgrade
                    echo '-------------------done setting up-------------------'
                else
                    echo "run this command from within your application"
                    exit 1
                fi
            }
            search_service_root_from_cwd "$(pwd)" "{{.service}}"
        fi

      # Print a newline to separate loading state from subsequent output
      # Commands to start your containers go here
      - >
        if [ "{{.action}}" == "up" ]; then
          echo "Loading complete. Starting Docker containers..."
          echo '---------------------------------------'
          echo "cleaning up the the repo to prepare for building the image..."
          yarn repo:reset
          echo '---------------------------------------'
          echo "cleanup done. Starting to build docker image....."
          echo '---------------------------------------'
          echo stopping any running containers'--------'
          echo '---------------------------------------'
          docker-compose down
          echo '==> firing up new containers. Get ready...'
          echo ðŸ’¥ðŸ’¥'------->'
          echo ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥'------->'
          sleep 1
          echo oh shit!! ðŸ¤¯ðŸ˜²'------>'
          echo '-----------------------------------------'
          pwd
          {{.docker_compose}}
        fi

    silent: true

  # Dynamically run services using node server engines PM2 in prod and nodemon in dev mode
  vanilla:*:*:
    vars:
      service: "{{index .MATCH 0}}"
      mode: "{{index .MATCH 1}}"
      # Set env_file based on whether mode is not 'prod'
      env_file: '{{ if ne .mode "prod" }}.env.{{.mode}}{{ else }}.env{{ end }}'
    cmds:
      - >
        [ -f ./microservices/{{.service}}/{{.env_file}} ] || 
        (echo "You need to add the {{.env_file}} file with environment variable configurations to proceed" && exit 1)
      - yarn repo:reset
      - yarn install
      - >
        yarn workspace @microservices-suite/{{.service}} '{{ if ne .mode "prod" }}{{.mode}}{{ else }}start{{ end }}'
    silent: true

  # TODO: Orchestrate services with kubernetes inside minikube clusters and kubectl
  k8s:*:*:
    vars:
      mode: "{{index .MATCH 0}}"
      service: "{{index .MATCH 1}}"
      #TODO: build dynamic file matching paths to k8 configurations here

      #TODO: build dynamic k8 commands here
    cmds:
      - "#TODO: enerate dynamic orchestration workflows based on [mode] & [service]"
    silent: true

  # TODO: Run your tests using jest or any test suite of choice
  test:*:*:
    vars:
      type: "{{index .MATCH 0}}" #type to match [unit,e2e,snapshot,all]
      service: "{{index .MATCH 1}}" #service to match [<service_name>,<glob-patterns>,all]
      #TODO: build dynamic file matching paths to test pyramid here

      #TODO: build dynamic test commands here
    cmds:
      - "#TODO: generate dynamic testing workflows based on [type] & [service]"
    silent: true

  # TODO: create a utilities glossary to switch {{.CLI_ARGS}} eg utilities: case --reset do; case --stop do; case etc
  reset:
    cmds:
      - "yarn repo:reset" #deep remove all node modules and artefacts generated during yarn install
    silent: true

